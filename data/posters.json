[
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3CEUF7",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/portrait_MpPKJYM.jpeg",
    "name": "Peter Bräuer",
    "code": "UTNWKL",
    "biography": "I received my Ph.D. in 2015 in Meteorology on the auto-generation of chemical mechanisms for atmospheric sciences and continued with 2 postdoc positions on chemical mechanism developments at the University of East Anglia and University of York in the UK. Since 2019, I work as a scientific programmer developing Julia scripts and packages for applications in satellite data analysis and meteorology."
   }
  ],
  "internal_notes": null,
  "notes": "",
  "created": "2020-03-06T18:19:12.834298+00:00",
  "description": "We will give an overview of the package’s capabilities and show first applications investigating contrail effects in aviation with spaceborne lidar measurements. We will explain the algorithm, which uses MATLAB’s Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) function to interpolate track data and finds intersections between trajectories, where the distance of coordinate pairs of the aircraft and satellite trajectory, respectively, approach zero.\r\n\r\nTemporal and spatial data of the intersections as well as relevant satellite and aircraft data are stored in structs for further analysis. The algorithm is highly adjustable so that it can be adapted for other applications such as investigation of ship tracks or cloud tracking. \r\n\r\nParameters exist to compromise between accuracy of results and computation time or allow to exclude certain data, e.g. below an altitude threshold of the aircraft, outside a time difference of the delay between the aircraft and the satellite overpass at the intersection or based on the presence or absence of clouds.\r\n\r\nSensitivity studies of the parameters and limitations of the current version will be discussed in detail.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "TrackMatcher – A tool for finding intersections in trajectories",
  "abstract": "_TrackMatcher_ is a Julia package for finding intersections between different trajectories. It is aimed at finding intersections of the flight paths of aircrafts and of satellite tracks, but is highly adjustable to any other user input. _TrackMatcher_ was developed to enable the investigations of contrail effects by aviation on the Earth’s radiation budget and climate with spaceborne lidar measurements."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3LZQXH",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Irene Ndindabahizi",
    "code": "GQ9VBT",
    "biography": "Mrs Irene Ndindabahizi is a doctoral candidate at the Royal Military Academy in Belgium. She holds a masters degree in Aerospace engineering. Her research interests are in the field of Vulnerability and Lethality."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-03T11:07:54.166375+00:00",
  "description": "Assessing the chances of survival of a vehicle’s crew under attack involves the computation of outcomes from a large number of attack scenarios. \r\nFor each scenario, the chances of crew survival are estimated using probabilistic computations involving a wide range of stochastics factors such as attack conditions, vehicle structural failure, debris path etc...\r\n\r\n The aim of this research is to build a framework that would ensure the propagation of uncertainties across the complete chain of computational models. It would then be possible to make an estimation of the main factors that contribute to crew survivability. These kind of simulations requires constant code extension with new models to simulate for instance outcomes from a collision between a “new” projectile and a “new” armour. A type hierarchy is used with multiple-dispatch that can be easily extended for new scenarios. To achieve our goal of code maintainability and extensibility, modularity is key. This is achieved using discrete event simulations in SimJulia, whereby the simulation advances by stepping through a list of events. Events are broken down into modules/tasks. To simulate a scenario is then a matter of combining tasks.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Vehicle's crew survivability using Julia",
  "abstract": "Computing the chances of survival of a crew means the simulation of a series of interdisciplinary problems. In this talk we will show how SimJulia is used as a platform for the simulation of these ballistics problems as discrete event."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "3NWY7V",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Dai ZJ",
    "code": "7T7WDF",
    "biography": "Machine learning platform developer"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2019-12-03T03:00:58.879704+00:00",
  "description": "JLBoost.jl implements XGBoost-like algorithm in pure-Julia. However, it's very hackable. I will give two examples\r\n\r\nFirstly, providing a custom loss function is very easy. \r\n\r\nSecondly, the node-to-split functionality is also customizable. In traditional tree-based machine learning (ML) models, at each step in the model-building algorithm, the algorithm chooses the best split by trying all features one by one; an innovation implemented by LightGBM is to try only the features that the node has split on in the previous round, this has major ramifications for the efficiency of the algorithm. It turns out that trying every feature has a major cost in that the data need to be sorted by the feature being tried, and sorting is computationally expensive. LightGBM gets around this by choosing the same feature and hence saves on computation (at the cost of over-fitting and slightly lower overall predictive power on average). It's not possible for the average user to hack the XGBooost C++ implementation to implement this unless you are the developer. With JLBoost.jl, you can achieve LightGBM's algorithm by providing a feature selection function which choose splits exactly as it would with LightGBM, which is highly customizable by you!\r\n\r\nJLBoost.jl lets you insert custom functions into key points in the algorithm so that you can customize many aspects of the tree-building process which in turns makes JLBoost.jl very hackable!",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "JLBoost.jl: Hackable XGBoost-like Gradient Boosting Tree Package",
  "abstract": "XGBoost is one of the most popular machine learning (ML) libraries for tabular data. JLBoost.jl is a pure-Julia implementation of XGBoost-like algorithms that is more hackable and plays nice with the rest of the Julia data ecosystem e.g. DataFrames.jl and JDF.jl.\r\n\r\nWhat makes JLBoost hackable? Something is hackable if you can customize it to incorporate novel features easily. I will show you why this is unique ot JLBoost and it not achievable with other XGBoost-like implementations."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "7LEVXF",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Gabriel Dansereau",
    "code": "W37LHD",
    "biography": "M.Sc Student in Computational Ecology at Université de Montréal"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-15T23:59:23.310452+00:00",
  "description": "We will present the main features of the `SimpleSDMLayers.jl` package, and show how it allows convenient manipulation of species distribution modelling outputs. Species Distribution Models (SDMs) are widely used in Ecology and Biogeography, mainly to predict where environmental conditions should be suitable for a given species on continuous geographic scales. Hence, SDMs require strong integration between bioclimatic data and spatial coordinates. [`SimpleSDMLayers.jl`](https://github.com/EcoJulia/SimpleSDMLayers.jl), developed by Timothée Poisot and the _EcoJulia_ organization, provides an efficient way to interact with these data in Julia, as well as a canvas on which SDM analyses can be built.\r\n\r\nThe package is built around the `SimpleSDMLayer` type, and stores bioclimatic data as **layers**. Each layer contains a `grid` field, which can store any type of data, as well as `left`, `right`, `top`, and `bottom` fields to store the bounding coordinates of a layer. This type allows extraction of data based on single coordinates or ranges. This type is intuitive and similar to the raster format used in Geographic Information Systems (GIS) for spatial data, while being easier to manipulate in the context of SDMs.\r\n\r\nThe package also implements default recipes for the `Plots` package, which allow efficient visualization and mapping of the bioclimatic variables and SDM outputs. The package handles missing data, and implements functions for operations such as resolution coarsening.\r\n\r\nAnother key feature of the package is its integration of the WorldClim 2.0 database, one of the most common source for climate data in SDM studies. WorldClim climate variable can be downloaded through the package and represented as `SimpleSDMLayers`. Theses layers can then be used in SDM models or represented using the plotting recipes of the package.\r\n\r\nOur presentation will demonstrate the key features of the package through concrete examples of bioclimatic data visualization and species distribution modelling. It is aimed at ecologists and biogeographers in the Julia community, as well as all scientists working with spatial data.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Simple Layers for Species Distributions Modelling in Julia",
  "abstract": "In this talk, we will present the `SimpleSDMLayers` package, which implements types and functions to interact with bioclimatic data and species distribution models in *Julia*. This package offers convenient integration between bioclimatic data and spatial coordinates, handles missing data, implements functions to download and manipulate WorldClim 2.0 data, and provides default plotting recipes allowing easier visualization of modelling results."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "8K8P7R",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "David P. Sanders",
    "code": "TJJRTG",
    "biography": "Full professor in the Faculty of Sciences, Universidad Nacional Autónoma de México (UNAM) and visiting professor at MIT.\r\n\r\nJulia user, tutorial developer and package author since 2014. Co-creator of the JuliaIntervals suite of tools for interval arithmetic in Julia."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-03T18:49:06.354844+00:00",
  "description": "We will show how to obtain fast global optimization of difficult\r\nunconstrained and constrained nonlinear programming problems in low and medium\r\ndimension, using branch-and-bound type, which is naturally highly parallelizable. To do so, we exploit some of Julia's unique features to transfer algorithms from the CPU over to the GPU.  We will discuss some of those features in detail and show how to combine them into different algorithms.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Fast global optimization on the GPU",
  "abstract": "We will show how to globally optimize multivariable functions on the GPU by exploiting Julia's unique capabilities in that area, using an algorithm of branch-and-bound type. We obtain up to 100x speedups on hard instances over a single CPU processor."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9JCCV8",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/IIKX3711_oPDuW5k.jpg",
    "name": "Rahma Latifa Dewi",
    "code": "VFSCTP",
    "biography": "My name is Rahma Latifa Dewi. I was born on 14 August, 1997 in Jakarta, Indonesia. I'm the first child in a family of three. My father, Mr. Mugiyantoro is a teacher in senior high school. My mother, Mrs. Fidyastuti is a housewife.\r\n\r\nI went to University of Indonesia, where I did my under graduate degree in Civil Engineer in 2015 until 2019. Since childhood, I was interested in exact. Derived from my Father, I also like to share my knowledge. Some of teaching experiences I have done since high school until now.\r\n\r\nOne of my teaching experiences in 2020 is teaching using Julia programming language. Started from the thesis topic that I worked on in 2018 together with my lecturer, Mr. Henki W. Ashadi. The title is Steel Truss Design using Julia Programming Language. The results of the thesis that I made are, structural analysis calculations such as internal forces, deflection, to the determination of steel profiles, just by using packages that have been available in Julia and several function.\r\n\r\nMy thesis can be used for learning in civil engineering lectures, especially for the calculation of steel frame structures. Currently, as many as 38 students are designing various skeletal models using my thesis in Julia. And I'm proud, my work can be useful for others."
   }
  ],
  "internal_notes": null,
  "notes": "",
  "created": "2020-03-03T05:58:47.858491+00:00",
  "description": "Designing building structure starts from calculating internal forces and displacement to determine the dimensions of structural elements. Finite element method based on matrix analysis is one method that can be used in analyzing structure. The problem in engineering education is the more complex the structure, the matrix more bigger and takes time to analyze. In this study, we will specifically discuss about Julia programming language as an open source software to analyze complex structure. Comparison with SAP2000 program will show that structure analysis with Julia programming language have same results and faster running speed. This proof will make Julia programming language begin to be used in civil engineering education in Indonesia. Currently, as many as 38 civil engineer students at University of Indonesia are designing various skeletal models using Julia Programming Language.",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/9JCCV8/poster_juliacon_9qbhHVQ.jpg",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Steel Truss Design using Julia Programming Language",
  "abstract": "Designing steel frame structures using the matrix method, often used in civil engineering lectures. But students often have difficulty when calculating matrices with larger dimensions along with the addition of degrees of freedom. Julia programming language is one of the new media used to design steel frame structures in Indonesia. only by using the available packages and the addition of some functions in Julia, can generate internal forces, deflection, and the steel profile design."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "9JFYBH",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Screenshot_from_2020-03-06_13-02-11_a8llaQL.png",
    "name": "Sam Buercklin",
    "code": "XPSFQS",
    "biography": "Buercklin began working at LeafLabs after the conclusion of his graduate studies in electrical engineering working on computational physics. He enjoys uncovering insight into physical systems through simulations and utilizing optimization and machine learning techniques to find new solutions to problems. As a researcher, his prior experience was in solving optical inverse problems and optimizing controls for quantum computing experiments. Outside of work, he can be found enjoying live music or riding his bike around Boston. (B.S. ECE at University of Illinois at Urbana-Champaign '15, S.M. EECS at MIT '19)"
   }
  ],
  "internal_notes": null,
  "notes": "",
  "created": "2020-03-06T18:04:19.379790+00:00",
  "description": "In computational neuroscience, spiking neural network (SNN) simulations are ubiquitous. SNNs can be used to reproduce biology and understand brain behavior, to explore neural networks as dynamical systems, or to sparsely encode and solve machine learning problems. Julia's inherent computational efficiency, flexible type system, and rich metaprogramming ecosystem leave it well posed to act as a preferred tool in this domain. Our contribution, WaspNet.jl, pairs Julia with the problem of clock-driven SNN simulation.\r\n\r\nWaspNet.jl is a lightweight neural network (NN) framework meant for fast, transparent simulations of NNs. The framework provides three layers of abstraction: neuron, layer or population, and network. \r\n\r\nNeurons are treated as black boxes relating an input signal to an output signal; in a spiking neuron, this means simulating a differential equation, although non-spiking neuronal models are also supported. Layers, or populations, are collections of neurons which orchestrate the simulation of constituent neurons and route inputs to their destination neurons. Networks comprise collections of populations and map signals between these populations.\r\n\r\nNetworks and layers are agnostic of the underlying neuronal models and provide the primary utility of WaspNet.jl. By leveraging Julia’s type system, we are able to write generic code for networks and layers which guarantees low overhead for simulations. This allows users to focus their efforts on neuronal models and network topologies.\r\n\r\nThe structure of WaspNet.jl and the temporal sparseness of SNN simulation lends itself well to parallelization. If no GPU is available, parallelizing computations in different layers across multiple cores is a natural extension; if a GPU is available, WaspNet.jl integrates easily with CuArrays.jl to further accelerate calculations. \r\n\r\nIn order to showcase the capabilities of WaspNet.jl, we exhibit benchmarks and NN experiments performed with the library. These experiments demonstrate the flexibility of WaspNet.jl to integrate distinct neuron types (spiking, non-spiking), topologies (feed-forward, recurrent), and acceleration techniques all from within the Julia language.\r\n\r\nAs of this writing, there is no actively developed, well-documented, fully-featured SNN simulator for Julia. By developing WaspNet.jl, we hope that we can make a meaningful contribution to the Julia, machine learning, and computational neuroscience communities.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "WaspNet.jl, a Julian Spiking Neural Network Simulator",
  "abstract": "We present WaspNet.jl, a framework intended for spiking neural network (SNN) simulations for computational neuroscience and machine learning. WaspNet.jl provides efficient implementations for SNN primitives and common neuronal models. This framework is robust to the neuron model, supporting both spiking and non-spiking neurons, allowing for novel hybrid topologies. We exhibit GPU acceleration with CuArrays.jl and demonstrate capabilities of WaspNet.jl with a variety of example experiments."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "AXTMXH",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Gajendra Deshpande",
    "code": "CPJQQS",
    "biography": "Mr. Gajendra Deshpande holds a master's degree in Computer Science and Engineering and working as Assistant Professor at the Department of Computer Science and Engineering, KLS Gogte Institute of Technology, Belagavi, Karnataka, India.  He has a teaching experience of 12 years and Linux and Network Administration experience of one year. Under his mentorship teams have won Smart India Hackathon 2018 and Smart India Hackathon 2019. He is the Technical Director for Sestoauto Networks Pvt. Ltd. and Founder of Thingsvalley. His areas of Interest include Programming, Web Designing, Cyber Security, Artificial Intelligence, Machine Learning, Brain-Computer Interface, Internet of Things and Virtual Reality. He has presented papers at NIT Goa, Scipy India 2017 IIT Bombay, JuliaCon 2018 London, Scipy India 2018 IIT Bombay, Scipy 2019 USA and PyCon France 2019."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-12T05:02:24.235940+00:00",
  "description": "When one thinks of learning programming as his/her first course there are two options available to a person. The first option is using visual programming tools like Turtle, Scratch, Blockly, and Alice. The second option includes learning the programming language directly by trying to understand the syntax and semantics of the language. However, visual programming tools are easy to use but may not be suitable for students in higher education in developing countries. Learning programming language itself is a challenge to the students of under-developed/ developing countries since many of the students are stuck in language syntax. Also for many students English not their natural language.  Flowgorithm can be thought of as a solution to both the above-mentioned problems. Flowgorithm is a free flow chart interpreter developed by Devin Cook. Flowgorithm enables the learner to draw the flowchart through the dragging and dropping of symbols. Once the flowchart is drawn in flowgorithm it generates pseudo code and program in selected languages. It supports around 18 languages including C#, C++, Java, JavaScript, Lua, Perl, Python, Ruby, Swift, Visual Basic .NET, and VBA. But it lacked the support of Julia. In this talk, I will explain how I created the Julia code generator for flowgorithm tool and demonstrate how to generate Julia code from the flowchart. The repository and instructions to use are available at https://github.com/gcdeshpande/Julia-Code-Generator.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia Code Generator for Flowgorithm Flow Chart Interpreter",
  "abstract": "Flowgorithm is a flowchart interpreter that can generate source code in a  few languages from a flowchart. But it could not generate the source code in Julia language. I have added the Julia language support for flowgorithm. In this talk, I will explain how I created the Julia code generator for flowgorithm tool and demonstrate how to generate Julia code from the flowchart. The repository and instructions to use are available at https://github.com/gcdeshpande/Julia-Code-Generator."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "B3E8NM",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Stephan Sahm",
    "code": "MJPZGQ",
    "biography": "Stephan Sahm is senior consultant at Machine Learning Reply for Data Science and Data Engineering. As an outstanding\r\nmaster of cognitive science, master of stochastics, as well as a\r\npassionate professional programmer he strives towards bringing tomorrow’s Data Science into today’s business.\r\n\r\nHe launched and organizes the Julia User Group Munich, the main driver for establishing Julia within Munich's Data Science community."
   }
  ],
  "internal_notes": "",
  "notes": "I am open about the format. I think a lightning talk would be fitting but also a poster is okay.",
  "created": "2020-03-15T21:05:47.735049+00:00",
  "description": "Dispatching on helper functions is extremely useful. Iterators are a perfect example: As everything can be an iterator we need to distinguish for some extra details in order to create optimal code. For instance whether something HasLength, HasShape{N}, IsInfinite, or has SizeUnknown. Binary functions also fall into this pattern - you may want to dispatch on whether something is `isempty()`.\r\n\r\nWithout  [Traits.jl](https://github.com/schlichtanders/Traits.jl)  you would use nested functions for this, like\r\n```julia\r\nf(a) = f_(a, Base.IteratorSize(a), Val(isempty(a)))\r\nfunction f_(a, ::Base.HasShape, ::Any)\r\n  # do ... for something which HasShape\r\nend\r\nfunction f_(a, ::Base.HasShape, ::Val{false})\r\n  # do ... for something which HasShape and is not empty\r\nend\r\n```\r\nWith the new [``Traits.@traits``](https://github.com/schlichtanders/Traits.jl) macro you can simply define them like\r\n```julia\r\nusing Traits\r\n@traits function f(a) where {Base.IteratorSize(a)::Base.HasShape}\r\n  # do ... for something which HasShape\r\nend\r\n@traits function f(a) where {Base.IteratorSize(a)::Base.HasShape, !isempty(a)}\r\n  # do ... for something which HasShape and is not empty\r\nend\r\n```\r\nThe ``@traits`` macro abstracts away the hidden complexity of the nested function, allowing you to seamlessly extend your traits-based methods.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "A new Traits.jl: Easily dispatch on whatever you want",
  "abstract": "Julia has the power to define arbitrary dispatch helpers, like for iterators there is ``IteratorSize``. My new package [Traits.jl](https://github.com/schlichtanders/Traits.jl) gives you the power to dispatch on such helpers directly as ``@traits f(a) where {Base.IteratorSize(a)::Base.HasShape} = \"awesome!\"``."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "BYDSZK",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/cormullion-logo-450_AusjzID.png",
    "name": "cormullion",
    "code": "RHJCGX",
    "biography": "bricoleur, putterer"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-04T12:59:14.043591+00:00",
  "description": "When working with Julia, we customize our working environment to make it personal to us. We choose our favourite operating system, text editor, desktop wallpaper, background music -  and of course the font that we use to display our code. In this talk I'll describe some of the challenges I've encountered in my ongoing experiment to see if it's possible to build a coding font particularly suited for Julia programming. I hope to be able to show a few snapshots of my progress.\r\n\r\nThe field of typeface design has been generating jargon for years - points, picas, and ems, glyphs, code points, entasis, counters, PUAs, contextual alternates, substitution tables, ligatures, UFOs, blueshifts - so I might mention in passing a few of these that I encountered as part of the process of making the font legible and readable with the coverage required by the Julia language.\r\n\r\nThis experiment might also find out whether it would be useful to have an open-source community-owned resource that contains all the characters and features that Julians - whatever their discipline or problem domain - might expect.",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/BYDSZK/screenshot_eoLMvga.png",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": true,
  "title": "A Julia coding font",
  "abstract": "As an experiment, I decided to create a monospaced programming typeface (aka font) designed for displaying Julia code. (Of course it should also work well for (legacy) code written in other languages!)"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "CHJ9ZK",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Harrison Grodin",
    "code": "YDWSNP",
    "biography": "Student at Carnegie Mellon University School of Computer Science, with a focus in programming language theory. Author of Rewrite.jl, Simplify.jl and developer for ModelingToolkit.jl."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-15T01:27:35.784054+00:00",
  "description": "How are \"static typing\" and \"dynamic typing\" related, and how could we use both to our advantage? Are there ways we can avoid the performance penalty associated with dynamic dispatch? Is it possible to make certain classes of bugs impossible to make, before even letting the code run? In this talk, we view the Julia language through the lens of programming language theory, considering these and other questions in terms of the current version of Julia and directions future versions could venture towards.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia, From a Programming Language Theory Perspective",
  "abstract": "We will examine the Julia programming language using formal programming language theory, attempting to characterize its features and behaviors in terms of existing formalism. Additionally, we will consider how ideas from PL theory could manifest themselves in future versions of Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "CMRXD7",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/clippederik.jpg",
    "name": "Erik Engheim",
    "code": "HDAYK8",
    "biography": "Erik has been programming in a variety of programming languages for the last two decades, primarily C/C++, Objective-C and Swift but has become a big fan of Julia and is currently doing Julia training videos and educational material.\r\n\r\nHe has spent many years in the Norwegian oil and gas sector working on 3D modeling software for reservoir modeling and simulation. Some of his interests include UX design, space exploration and colonization, micro controllers and green tech."
   }
  ],
  "internal_notes": "",
  "notes": "The talk is not meant specifically for people interested in GUI design. It is primarily to show the versatility of Julia in solving tasks outside of the typical Julia Scientific Computing. This was a tool I used effectively as a C++ developer for my work, even if my company did not support Julia as a development platform.",
  "created": "2020-01-08T13:30:55.431953+00:00",
  "description": "The Qt GUI toolkit is used to make large and complex user interfaces. Unfortunately these become hard to maintain and change whether they are written in C++ or designed visually with the Qt Creator IDE. Here we show a DSL implemented in the QtUIParser package, which allow you to convert back and forth between .ui files and .jl files. Hence you can design a UI in Qt Creator. Convert to Julia UI DSL. Modify it in the Julia REPL and then take it back in Qt creator for further processing.\r\n\r\nThat this targets Qt, is not important. The principles could be applied to any GUI toolkit, where UIs are stored in an XML, JSON or similar format.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Using Julia for User Interface Design",
  "abstract": "Using Julia to create a Domain Specific Language (DSL) suitable for editing graphical user interfaces. In this example our DSL can be used to edit .ui files produced by the Qt Creator GUI design tool for the Qt  GUI toolkit."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "CXAYML",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Daniel Kool",
    "code": "DRPANN",
    "biography": "I am a PhD student at Iowa State University, working on evaluation of protein mutations and analysis of protein variants."
   }
  ],
  "internal_notes": "",
  "notes": "BioMakie.jl is in the earliest stages, and it is hard to tell exactly where it will be by the time of the presentation, but it will hopefully at least have interactive protein structures and multiple sequence alignments. I plan to add easy retrieval of data from public databases like PDB/CATH/SCOP/Pfam also, for fast and easy exploration.",
  "created": "2020-03-15T21:42:14.270195+00:00",
  "description": "",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [
   {
    "description": "Poster",
    "resource": "/media/juliacon2020/submissions/CXAYML/resources/BioMakie_RjHgcTk.pdf"
   },
   {
    "description": "structure view",
    "resource": "/media/juliacon2020/submissions/CXAYML/resources/2vb1_HkqWHdE.png"
   },
   {
    "description": "shape animation",
    "resource": "/media/juliacon2020/submissions/CXAYML/resources/shapeanimation_KE2Pujj.webm"
   }
  ],
  "do_not_record": false,
  "title": "Visual Biology with Makie",
  "abstract": "I'll be showing some applications of Makie for biological visualization including protein structures and multiple sequence alignments. BioMakie.jl will also be introduced as a dedicated package for biological visualization using Makie."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "D3RLQ7",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Marc Fuentes",
    "code": "8EXT8Q",
    "biography": "After being graduated in applied mathematics (Ph.D. in the University of Toulouse in 2007), M. Fuentes integrated  the French National Institute for Research in Computer Science and Automation (INRIA) and becomes a Research Engineer. At INRIA,  his mission consists in\r\nimproving software quality trough better development practices. His main interests are\r\ncomputer langages for doing maths and linear algebra"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-06T22:21:23.382475+00:00",
  "description": "Most of the time, researchers have to deal with parameter optimization of their simulation model. \r\nTheir simulation model runs generally as a parallel code written in Fortran, C or C++ using MPI libraries. \r\nIn this talk, we want to show how to connect a MPI Fortran code with Julia using *MPI.jl* package and *ccall* function\r\nand thus benefits from all advantages of our favorite language, such as the Optim.jl package\r\n\r\nExamples will start with simple objective functions like $\\frac{1}{2}\\|x-c\\|^2$ and\r\nand pursue with more complicated examples such as the heat equation. Some experiments on \r\nhow to manage the process optimization will be given. We will also report some demonstrations\r\nusing opencoarrays instead of MPI library.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Calling a parallel simulation code from Julia",
  "abstract": "We want to share our personal experience about calling MPI fortran program from Julia and \r\ncarrying out parameter optimization on it."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "EM8ZK3",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/mq_KkSobXj.jpg",
    "name": "Marco Quartulli",
    "code": "ZGQL3X",
    "biography": "Marco Quartulli holds  a PhD in EE and CS from the\r\nUniversity of Siegen, Germany, in 2005. From 2000 to 2003, he was with\r\nthe German Aerospace Center (DLR) in Germany, working on machine\r\nlearning for image understanding and content-based image retrieval.\r\nFrom 1997 to 2010 he worked on remote sensing ground segment\r\nengineering, image analysis, archive search for Advanced Computer\r\nSystems, Italy. Since 2010, he has joined Vicomtech in Spain where he\r\nis working in the Data Intelligence for Energy and Industrial\r\nProcesses department on the development of ML- and AI-based predictive\r\nand prescriptive analysis methodologies for high-dimensional\r\nmultivariate time series."
   }
  ],
  "internal_notes": null,
  "notes": "The talk image will be updated ASAP.\r\nThe current one is a fast screenshot of a video recording of the Makie animation superimposed with comments and explanations.",
  "created": "2020-03-06T12:49:58.985537+00:00",
  "description": "Industrial processes are typically well controlled. State space trajectory\r\ncycles are repetitive, except for expected / controlled variations due to\r\ncontrolled factors. Minor variations typically appear as noise.\r\n\r\nWhen faults occur, trajectories drift, diverging from the observed/expected\r\nones.\r\n\r\nAs a consequence, near-real time parametric N-dimensional curve reconstruction\r\nfrom very high frequency data streams depicting temporally limited sections of\r\nsparsely sampled, low resolution and high noise trajectories of e.g. machining\r\nheads and laser beams can be valuable in industrial settings for applications\r\nranging from security monitoring and quality assurance to control.\r\n\r\nWhenever trajectories are sampled densely, we can use model inversion (by e.g.\r\nrecursive least squares) and online updates to accumulate knowledge on\r\nprocesses during many process instances (e.g. cycles) at many time series\r\npoints in terms of robust statistics of the estimated model parameters.\r\n\r\nWe can then detect and isolate fault conditions early, in a predictive\r\nmaintenance scheme operating at the micro-level (how much time till failure?)\r\nand intra-cycle (is the current process instance currently diverging?) rather\r\nthan per process instance (how many cycles till failure?).\r\n\r\nIn this contribution, we present methods for rapid reconstruction from partial\r\nnoisy data of curves from parametric families. The inversion operates in\r\nstreaming mode, in the sense that it works by maintaining and updating a\r\nsnapshot of the acquired data representation and that is only allowed a limited\r\nnumber of accesses to the data stream which is not Random Access. The inherent\r\nuncertainty is treated by considering a Bayesian inversion framework. Specific\r\nattention is devoted to the exploitation of the conditional independence\r\nstructure of the problem for the derivation of a concurrent problem definition\r\nthat lends itself to its integration in a high performance visualization\r\ncomponent built on Makie.jl. The produced implementation is generic with\r\nrespect to the family of curves supported.",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/EM8ZK3/makie_frame_xpoKtKY.png",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Bayesian curve reconstruction from noisy streams in Julia",
  "abstract": "Parametric curve reconstruction from partial noisy data is useful for\r\nmonitoring repetitive industrial process state space trajectories. We\r\niteratively estimate the parameters of a Bayesian model by recursive least\r\nsquares fitting using LsqFit.jl, integrate them in time updating online robust\r\nstatistics via OnlineStats.jl, showing a representation built on Makie.jl and\r\ntested on simulated 3D trajectories and on real data from battery testing\r\nexperiments."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "ENRJBB",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Janis Erdmanis",
    "code": "BYKXMD",
    "biography": "My name is Janis (Yanis), and I am currently a PhD candidate for theoretical physics at TU Delft.  I am a curious person and simplicity is what drives me. I am passionately seeking a frame of reference in which perceived complexity becomes simple, short and understandable. That gives me a kinda special feeling of going up to see more. And in the research, I get plenty of opportunities to do that although that is never easy. So I end up building my own stuff with Julia, now I am the founder of PeaceFounder's project."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-05T20:35:35.425064+00:00",
  "description": "Often when we face an embarrassingly parallelizable problem which runs a long time, we reach out for a single `pmap`, and if we are lucky, we can run that on the cluster with plenty of cores. However, often we are faced with resources in front of us. In such a case, it is worth to think whether an evenly spaced grid is the most optimal one. \r\n\r\nChoosing an optimal grid for the function in advance is often a problem itself more significant than waiting a little extra time. Instead, it would be great if the grid itself would adjust as more knowledge of function comes in during evaluation. Which thus forms a feedback loop.\r\n\r\nIntroducing parallelism to a feedback loop in a way that it would allow deterministic debugging while not staling resources is tricky. Additionally, the feedback loop should be completely independent of the hardware it is executed (CPU, GPU, Cluster jobs, etc.) and preferably sit in a separate package. The question I found fascinating was what would be the best abstractions to such problem in Julia, which gave rise to the `TaskMaster` package.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "How to not lose a mind by paralelizing a feedback loop?",
  "abstract": "Feedback loops are notoriously hard to reason and debug when parallelism is introduced. Thus in this poster, I will describe abstractions introduced in `TaskMaster` package for concurrent feedback loops which one can replay to debug. Lastly, I will demonstrate how it can be used together with `Adaptive`, a wrapper for corresponding `python adaptive` package, as an alternative to `pmap`."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "EZFAJE",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/MAO_f2GqE8Y.JPG",
    "name": "Mikel",
    "code": "UNYAWF",
    "biography": "Bachelor of Computer Science (1992) and Doctorate (2017) at the UPV / EHU.  2011-2012, professor  in the Department of Computer Science and Artificial Intelligence.  Since 2017, professor of the School of Engineering of Gipuzkoa in the Department of Applied Mathematics.\r\n\r\nResearch area:  Analysis and implementation of advanced methods for the numerical integration of problems modeled by ordinary differential equations (ODE)\r\n\r\nWithin the field of Computer Science, he has developed the following lines of research:  efficient implementation of numerical integration methods applied to the simulation of the solar system and orbit propagators for satellites\r\n\r\nArticles: https://orcid.org/0000-0002-7321-8882"
   }
  ],
  "internal_notes": "",
  "notes": "- Project repository: https://github.com/mikelehu/IRKGaussLegendre.jl\r\n- Authors: M. Antoñana, E. Alberdi, J. Makazaga and A. Murua\r\n(UPV/EHU University of Basque Country)",
  "created": "2020-03-02T08:46:16.475498+00:00",
  "description": "DifferentialEquations.jl is a modern ecosystem for solving differential equations in Julia that is still under heavy development and it includes a suite specifically designed for researchers interested in developing new methods for differential equations.  So, we have considered a promising implicit RK method, called IRKGL16,  and we have fully integrated it on  DifferentialEquations.jl ecosystem.\r\n\r\nThe family of implicit Runge-Kutta schemes based on collocation with Gauss-Legendre nodes are known to be symplectic and super-convergent (order 2s for the method with s internal nodes), and thus very convenient for the high precision numerical integration of Hamiltonian systems with constant time-step size.  For non-stiff problems, implementations based on fixed-point iterations are recommended. \r\n\r\n We believe that, for general (non-necessarily Hamiltonian) non-stiff ODE systems,   such implicit Runge-Kutta methods (implemented with fixed point iteration) can be very competitive for high precision computations (for accuracy requirements that exceeds double precision arithmetic). We present an implementation of a 8-stage IRK of order 16 for non-stiff ODEs with adaptive time-stepping, and compare its efficiency with standard non-stiff solvers.\r\n\r\n- Project repository: https://github.com/mikelehu/IRKGaussLegendre.jl",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Implicit RK solver for high precision numerical integration",
  "abstract": "We present a Julia implementation of a 16th order Implicit Runge-Kutta integrator IRKGL16 (a 8-stage IRK scheme based on Gauss-Legendre nodes) for high accuracy numerical integration of non-stiff ODE systems.  Our  algorithm supports adaptive time-stepping, mixed precision and multithreading to solve problems fast and  accuracy.\r\nWe show that our implicit solver is more efficient than existing explicit solvers for accuracy requirements that exceeds double precision arithmetic."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "G7XNXE",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Tom Kwong",
    "code": "ZVXXQA",
    "biography": "Tom Kwong, CFA, is an experienced software engineer with over 25 years of industry programming experience. He has spent the majority of his career in the financial services industry. His expertise includes software architecture, design, and the development of trading/risk systems. \r\n\r\nSince 2017, he has uncovered the Julia language and has worked on several open source packages, including SASLib.jl. He is also the author of the book Design Patterns and Best Practices with Julia, published by Packt in January 2020.\r\n\r\nHe currently works at Western Asset Management Company, a prestigious asset management company that specializes in fixed income investment services. He holds an MS degree in computer science from the University of California, Santa Barbara (from 1993), and he holds the Chartered Financial Analyst® designation since 2009."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-02-24T05:39:17.055851+00:00",
  "description": "In general, the following facilities are available:\r\n- Use `@ctx` macro to annotate functions that participates in context tracking\r\n- Use `@memo` macro to memorize variables in the context\r\n- Use `context` function to retrieve memorized data\r\n\r\nContextTracking.jl can be used in conjunction of a logging library such as LoggingFacilities.jl.  Since context information is available during the entire execution stack, they can be logged at the same time and allow easier debugging in a production system.\r\n\r\nThis package is thread-safe and can be used with async tasks.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "ContextTracking.jl - do you know where you are?",
  "abstract": "When using Julia in a production system, it is important to have adequate logging such that one can generate useful application analytics and track down problems and respective root causes.  ContextTracking.jl is a package that helps track execution context and provides a context-sensitive logger.  For ease of use, there are few macros for annotating functions and memoizing contextual data."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "GZK8ML",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Tom Kwong",
    "code": "ZVXXQA",
    "biography": "Tom Kwong, CFA, is an experienced software engineer with over 25 years of industry programming experience. He has spent the majority of his career in the financial services industry. His expertise includes software architecture, design, and the development of trading/risk systems. \r\n\r\nSince 2017, he has uncovered the Julia language and has worked on several open source packages, including SASLib.jl. He is also the author of the book Design Patterns and Best Practices with Julia, published by Packt in January 2020.\r\n\r\nHe currently works at Western Asset Management Company, a prestigious asset management company that specializes in fixed income investment services. He holds an MS degree in computer science from the University of California, Santa Barbara (from 1993), and he holds the Chartered Financial Analyst® designation since 2009."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-15T00:18:22.991764+00:00",
  "description": "While Julia does not have official support for interface/traits, a number of traits packages was developed as proof of concepts (SimpleTraits.jl, Traitor.jl, and more recently Traits.jl).  When people don't want to use  third-party packages, they resort to Holy Traits - a design pattern that is fairly easy to implement. \r\n\r\nBinaryTraits provide several macros that make it easier to work with traits.\r\n- A `@trait` macro for defining new traits.  Traits are binary - a data type either has the trait or don't.\r\n- An `@implement` macro for specifying interface contracts for data types exhibiting a trait.\r\n- An `@assign` macro for assigning a data type to a trait.\r\n- A `@check` macro for verifying that a data type conforms to the interface contract as specified by the trait.\r\n- A `@traitfn` macro for creating dispatching functions as in Holy Traits pattern\r\n\r\nBinaryTraits is expected to be used by framework providers that define formal interfaces.  As an example, we could create a `RowTable` trait and put that in Tables.jl.  Then, implementers can assign their data types to `RowTable` and they can verify correctness of their extension easily.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "BinaryTraits - traits made easy",
  "abstract": "BinaryTraits is yet another traits package.  Its primary goal of the project is to make traits easy to use.  The underlying mechanism is Holy Traits.  If you think Holy Traits is the powerful engine, then BinaryTraits gives you automatic transmission.  It makes traits a lot more pleasant and fun to use."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "HPR79A",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Oscar A. Esquivel-Flores",
    "code": "GYDYSB",
    "biography": "Oscar A.  Esquivel-Flores received his Bachelor's degree in Applied Mathematics and Computing from Universidad Nacional Autónoma de México (UNAM). M.S. degree in Computer Sciences from Universidad Autónoma Metropolitana, México and PhD degree in Computer Engineering from UNAM in 2013. He has working on parallel and high performance computing as part of a posdoctoral position at the Barcelona Supercomputing Center as an international agreement with National Council of Science and Technology of México. He currently helds a research position in Instituto de Investigaciones en Matemáticas Aplicadas y en Sistemas at Universidad Nacional Autónoma de México developing parallel algorithms regard matrix computations, machine learning and optimization."
   },
   {
    "avatar": "https://pretalx.com/media/avatars/%C3%ADndice_yUuDMkO.jpeg",
    "name": "Óscar Alvarado",
    "code": "ZZTWND",
    "biography": "Degree in physics. Currently studying data science and interested in AI, high-performance computing, and computational physics.\r\nStudying at the National Autonomous University of Mexico."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-12T05:52:57.750082+00:00",
  "description": "The biometric pattern recognition area is very important in the industry, particularly for security and authentication reasons. Face recognition is commonly used in device unlocking and controlled accessibility, as well as being present in different Internet of Things (IoT) applications. Computer Scientists work on increasing the effectiveness of the three most representative algorithms for face recognition: PCA, HOG and CNN. Parallel implementations of these algorithms using a high-level programming language and graphic accelerator devices help to show the advantages and disadvantages of each of these algorithms related to accuracy. CUDAnative.jl wrapper facilitates the design of CUDA kernels, optimizes matrix calculations through CUDArray objects creation and wraps the low-level programming required when using pure CUDA.\r\n\r\nThe main disadvantage that these algorithms share is that their execution is slow, for instance, PCA carries out a brute force strategy when comparing the complete set of images, equivalently the CNN algorithm is slow in training the neural network; such that the parallelization of these algorithms is an important option worth considering.\r\n\r\nDifferent image databases such as \"Extended Yale Face Database\", \"The AR Face Database\", \"Face94 face Database\" and \"Labeled Faces in the wild dataset\"  were used to confirm that there is no overfitting in each of the algorithms mentioned above, some evaluations were made to find the algorithm with greater accuracy in the classification.\r\n\r\nThe advantages offered by Julia combined with the CUDAnative.jl wrapper are significant since it facilitates the development of parallel algorithms that are executed in graphic processing units, speeding up their execution without the need to understand CUDA's low-level programming paradigm in detail.\r\nWe would like to thank the financial support of PAPIIT-IA104720.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Parallel face recognition algorithms using Julia + CUDAnative.jl",
  "abstract": "Three important algorithms for face recognition are implemented and tested in this work. Principal Component Analysis (PCA) or eigenfaces, Histogram Oriented Gradients (HOG) and Convolutional Neural Networks (CNN) are computationally demanding algorithms.\r\nTo obtain performance improvements, parallel algorithms were designed using Julia 1.1.0 and graphic processing units through CUDAnative.jl which provide effortless development and scalability. This work is supported by PAPIIT-IA104720"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "LSYN8F",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Tim Holy",
    "code": "J9BSUH",
    "biography": "I am the Alan A. and Edith L. Wolff Professor of Neuroscience at Washington University in St. Louis.\r\nI contribute to Julia and its package ecosystem, particularly in developer tools and image processing."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-03T16:07:26.000612+00:00",
  "description": "",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Automatic gradient and scale for high dimensional optimization",
  "abstract": "Optimization and machine learning must tune models to fit data. Large-scale problems are typically optimized using a variant of gradient descent, where the gradient is calculated automatically, but having such limited information about function behavior slows progress. I will describe mathematics and code for extracting the gradient and \"scale\"—an upper bound on the diagonal quadratic remainder in a Taylor series expansion—and how having both quantities available enhances optimization."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "M8KTBL",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Joris Kraak",
    "code": "VCBWCT",
    "biography": "Joris is a software engineer with a background in signal processing and a passion for automation, clear and clean software and the infinite possibilities of the Internet."
   }
  ],
  "internal_notes": "",
  "notes": "We have been using (some of) these diagramming languages for a couple of years within our research organization to document code and systems and have found them to be very valuable. This has been mostly in an ad-hoc fashion, but we are currently building tighter integrations with Julia. These integrations are under active development at the time of writing and have not yet been released to the open-source community. The aim is to have (a version of) these integrations available at the time of the conference.\r\n\r\nEven without these integrations, the value of the techniques holds even though they carry a higher maintenance burden.",
  "created": "2020-03-15T23:00:54.112863+00:00",
  "description": "A wide variety of textual diagramming languages are available across various language ecosystems (e.g. [Mermaid](https://mermaid-js.github.io/mermaid), [PlantUML](https://plantuml.com), [ditaa](http://ditaa.sourceforge.net/), etc.). These diagrams tend to be well readable in their textual form and can be easily turned into nice looking images where richer representations are available. This makes these languages particularly well suited for the documentation of software. The corresponding diagrams can be defined close to source code making them readily available, while also looking good in rendered documentation.\r\n\r\nAlthough these languages can always be used to generate the desired diagrams in an ad-hoc manner, having a tight integration with a language and its tools decreases the maintenance burden. This poster will demonstrate some tools and techniques to achieve this integration.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Fantastic beasts and how to show them",
  "abstract": "When getting into the internals of software systems developers can greatly benefit from visual aids. We will demonstrate tools and techniques maintainers can use to easily create diagrams visualizing (components of) their software, aiding potential contributors (and themselves) in future explorations."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "N9CXCT",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/DSC05170.jpg",
    "name": "Arnav Sood",
    "code": "BLMFSS",
    "biography": "Arnav is a Predoctoral Researcher at the UBC Vancouver School of Economics, where he works primarily with Jesse Perla. He is also a team member at QuantEcon, contributing to Julia projects and lectures."
   }
  ],
  "internal_notes": "",
  "notes": "The references for our package are in the docs, but the key ones are FastGaussQuadrature.jl (https://github.com/JuliaApproximation/FastGaussQuadrature.jl), and Patrick Mogensen's former DistQuads.jl (https://github.com/pkofod/DistQuads.jl).",
  "created": "2019-12-06T18:43:05.255597+00:00",
  "description": "Traditional ways to compute arbitrary expectations are Monte Carlo methods (expensive, and perhaps inaccurate) or \"roll-your-own\" numerical integration (tricky to implement.)\r\n\t\t\t\r\nIn Expectations.jl (https://github.com/QuantEcon/Expectations.jl), we export callable operators around Distributions.jl objects, defined by compact vectors of adaptive Gaussian quadrature nodes and weights. The operators adhere to mathematical properties (e.g. scalar multiplication), improving clarity.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Extending Distributions with Expectations.jl",
  "abstract": "Many statistical problems involve taking expectations of (some function of) a random variable. Expectations.jl defines fast and reusable operators that are highly accurate. Univariate mixture models are also supported. We explain the math (Gaussian quadrature) and design, and demonstrate their use."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "NETNQZ",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Eric Torkia",
    "code": "WGC3SZ",
    "biography": "I am currently the executive partner and analytics practice lead at Technology Partnerz Ltd., a firm specialized in delivering analytics solutions focused on forecasting, simulation and optimization to organizations all over the world. As practice lead, I have advised senior leadership on analytics strategy and implementation, trained hundreds of business analysts on predictive analytics, lead or supported risk analysis initiatives in finance, operations as well as project cost and schedule risk."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-02-13T21:48:36.395060+00:00",
  "description": "MCHammer provides all the tools of modern simulation tools add-ins (such as Oracle Crystal Ball, Palisade @Risk, etc. ) in a simplified command line. Major features to cust modeling time and time to answer are discussed :\r\n\r\n•\tCorrelation of Simulated Inputs (Iman-Conover[1982]) \r\no\tCovariance Matrix\r\no\tRank Order Correlation Matrix\r\no\tPearson Product Moment Correlation Matrix\r\n\r\n•\tData Analytics tools for analyzing both simulation results and exploratory analysis of historical datasets\r\no\tDensity & Histogram Charts with Descriptive Stats\r\no\tDensity \r\no\tHistogram\r\no\tTimeSeries Trend Chart\r\no\tSensitivity Analysis Charts\r\n\r\n•\tSensitivity Analysis Chart \r\no\tRank Correlation\r\no\tPPMC\r\no\tContribution to Variance %\r\n\r\n•\tTimeSeries simulation \r\no\tTime Series using Simulated Random Walk\r\no\tTime Series using Historical Data to calculate parameters for Simulated Random Walk\r\no\tTrend Charts with Customizable Confidence Bands\r\n\r\n•\tImport / Export of results using the SIPMath standard.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Decision Modeling and Simulation with MCHammer.jl",
  "abstract": "Julia provides incredible flexibility for migrating tedious data processing and decision/risk modeling that happens currently in Excel but no packages existed to automate or simplify the processing of simulation results. Inspired by the many Excel add-ins that were created to automate the many steps in the Monte-Carlo Simulation algorithm (including correlation and results visualization), we created a similar time-saving toolkit  for Julia called MCHammer."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "NX33Q8",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Indranil Ghosh",
    "code": "DCJ8DG",
    "biography": "Indranil Ghosh is a Post Graduate student in the Physics department from Jadavpur University Kolkata. He has been involved in research related to scientific computing and has presented in three international conferences held in India and has also  presented his work on designing simple python programs to study quantum game theory applicable to population evolution,  in SLAS,2019 International Conference and Exhibition held at Washington DC, USA, in February 2019. He has presented a talk on simulations of quantum game theoretic models in Scipy India, 2018, conference and a talk on application of scientific computing in SNBNCBS, Kolkata. He has also presented in ISI, Kolkata on a topic related to designing a Pygame program to study fractal patterns in Non-linear Dynamics. He has also been involved in writing the book “Computational Methods in Physics with Python” under the supervision of Dr. Debasish Lohar, present HOD of Physics Department, Jadavpur University, and this project is planned to be completed within the next semester."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2019-12-13T07:57:33.631625+00:00",
  "description": "One of the many enthralling applications of quantum computing is formulating the quantum versions of the classical game theory models which results in many interesting outcomes. In this presentation, games like Spin Flip Game, Quantum Prisoner’s Dilemma (QPD), Quantum Newcomb’s Game and Quantum Hawk and Dove are demonstrated with Julia. This field has found numerous interdisciplinary applications. QPD, for example, helps in the study of Evolutionarily Stable Strategies in biophysics.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Quantum Game Theory with Julia: A computational analysis",
  "abstract": "Quantum Game Theory is an emerging interdisciplinary field concerning Quantum Physics and Game Theory. I will be delivering a talk on using Julia to simulate various quantum game theory models, that will be of special interest to the community."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "NXKNRM",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/SKI_profile_eroR5sQ.jpg",
    "name": "Konstantinos Samaras-Tsakiris",
    "code": "LTE8PA",
    "biography": "Konstantinos is a cloud engineer at CERN on a sidequest to understand intelligence.\r\nAfter a software engineering internship and taking his Electrical and Computer Engineering degree, he's back at CERN designing web infrastructure on Kubernetes.\r\nBy night, he lets his curiosity loose on how our brains work, trying to apply his software skills to help further these questions."
   }
  ],
  "internal_notes": "",
  "notes": "If a talk is not accepted, I could present a poster.",
  "created": "2020-03-15T23:35:17.993261+00:00",
  "description": "We describe the design of [HierarchicalTemporalMemory.jl](https://github.com/Oblynx/HierarchicalTemporalMemory.jl), a Julia package that implements an algorithmic model of intelligence, the Hierarchical Temporal Memory. The main algorithms of this model, the Spatial Pooler and Temporal (Sequence) Memory, are described with concise tensor expressions in:\r\n- [The HTM Spatial Pooler—A Neocortical Algorithm for Online Sparse Distributed Coding](https://www.frontiersin.org/articles/10.3389/fncom.2017.00111/full)\r\n- [Continuous Online Sequence Learning with an Unsupervised Neural Network Model](https://www.mitpressjournals.org/doi/10.1162/NECO_a_00893)\r\n\r\nThe official implementation of this model in Python ([NUPIC](https://github.com/numenta/nupic)) serves as a reference point and as source of truth for many implementation details, but it doesn't take advantage of the data-driven design that the source material encourages and ends up quite verbose. This implementation uses Julia's expressivity to remain faithful to the papers' terminology, attempting to express the algorithms more simply and concisely, and thus instigate further research on them. Some essential features of this expressivity are broadcasting, duck-typed interfaces and unicode source code.\r\n\r\nThe Hierarchical Temporal Memory (HTM) is a biologically constrained theory, aiming primarily to model the function of the neocortex (a structure of the human brain), and as a secondary goal, machine learning applications. The algorithms expose many fundamental properties which we use to test this implementation.\r\n\r\nIn contrast to many established neural network models, the HTM neuron performs coincidence detection across multiple input \"dendrites\". HTM is actually closer to a spiking neural network, with binary synapses and signals, that encodes information in population codes. Spatial pooling and the temporal memory are both unsupervised processes that adapt continuously; together, they learn to identify sequences in noisy input time series.\r\n\r\nHTM theory is not yet complete, lacking a definitive way to stabilize sequence representations and compose small models. Exactly for this reason, we believe that a concise and high level model can accelerate the research.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "HierarchicalTemporalMemory.jl: a short delta from paper to code",
  "abstract": "We will show how an algorithmic model of intelligence can be expressed concisely in Julia, closely mapping the definitions in the literature that describes it. This new package that implements a biologically constrained model of mammal intelligence can serve as a theoretical framework to guide neuroscience research or perform machine learning tasks like time series prediction and anomaly detection."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "QDD7G7",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Jesse Bettencourt",
    "code": "EL3WH8",
    "biography": "Graduate student in Machine Learning at University of Toronto"
   }
  ],
  "internal_notes": "",
  "notes": "At the moment this method is implemented in JAX (Python) but the talk will not be specific to that implementation and will hopefully be useful towards a Julia implementation.",
  "created": "2020-03-15T02:34:56.462784+00:00",
  "description": "Higher-order AD can be readily achieved by composing first-order AD, differentiating the emitted code from the lower orders. However, naively nesting first-order AD can require a number of evaluations exponential in the order of differentiation. This is because the contributions of lower-order derivatives to the higher orders are complicated, given by a general formula called Faa di Bruno, which generalizes the chain rule to higher orders. Further, naively nesting first order differentiation may not efficiently share the results computed from lower orders. Many expressions that appear in higher derivatives were required to compute the lower orders, and recomputing these expressions will result in exponential time cost `O(exp K)` in differentiation order `K`.\r\n\r\nFortunately, there is a known solution in the AD literature, which we are calling Taylor-mode. This recognizes that the terms from higher-order differentiation are exactly the coefficients to a truncated Taylor polynomial (up to constant factor scaling by factorial of order). The desired higher derivatives of a composite function an be computed by propagating Taylor polynomials through primitive functions.\r\n\r\nThe implementation details are a direct generalization of first-order AD via \"dual numbers\". We define propagation rules for primitive operations, not just for the first order sensitivity, but for higher order sensitivities. This allows us to propagate Taylor polynomials through functions composed of primitive operations. In general, these operations will follow the Faa di Bruno formula and require sub-exponentially evaluations `O(exp sqrt K)`. However, many of the primitive operations we care about in practice have special forms and can have propagation rules that scale like `O(K log K)`.\r\n\r\nFirst-order AD is a fundamental tool in machine learning, for gradient-based optimization, and has modern, scalable implementations that integrate well into popular tools. However, higher-order AD has not found wide use-cases, and the existing implementations do not integrate into machine learning research tools.\r\n\r\nThere is a special relationship between Taylor polynomials and ODEs. To exploit this relationship with Neural ODEs, we need AD tools that work with numerical integration, higher-order Taylor derivatives, and that scale to many parameters found in machine learning models. Further, we can use these tools to improve known algorithms for computing higher derivatives of solutions to ODEs.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Taylor-Mode for Higher Order Automatic Differentiation",
  "abstract": "Higher-order AD can be achieved by nested calls to first-order AD, but this approach costs exponential in the order of differentiation. Taylor-mode AD is a known alternative method for efficiently computing higher derivatives. I describe this method, suitable for machine learning, capable of computing higher derivatives of large neural networks. I describe improvements to the algorithm for computing higher derivatives of ODE solutions to be matrix-free and scalable to high-dimensional systems."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RBTYQR",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Capture_Ek5JF1v.JPG",
    "name": "Shiqi XIAO",
    "code": "UUX8FW",
    "biography": "BSc Chinese University of Hong Kong\r\nMSc ETH Zurich"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-04T05:54:46.275573+00:00",
  "description": "The small air parcel can be broken down into two parts within the special weather diagram: the dry part and the wet part. Both two will rise on two conserved quantities until they meet, with saturated water vapor. Then a new process will start as the parcel continue to rise. The energy available for convection, and the energy required to start convection. Those analyses can be achievedin a chart called tephigram.\r\n\r\nThe mathematical principles of making the special weather diagram, which is called tephigram, is also presented in Julia programming. One of the basic ideas are transformation of cartesian coordinates. The two most important mathematical tools  involved in this weather diagram are solving analytic geometry, and the calculus in the form of Julia functions. \r\n\r\nThe most computationally challenging part is to plot and label multiple lines (or contours) of a specific variable, and the weather profile in a plot, which results in more than 30 seconds to generate the tephigram in Julia programming.",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/RBTYQR/Tephigram_sdNZ9oQ.jpg",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "What can imply behind a special weather profile",
  "abstract": "The weather might seem calm several minutes before a severe weather. This really needs a special weather vertical profile to reflect temperature, pressure (and dew point temperature) to analyze a parcel rising from any vertical level in interest. And the principle of Julia programming to plot this diagram, which is calculus and analytic geometry, is shown to the public."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RDMYLS",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Chidubem Iddianozie",
    "code": "UPKRFZ",
    "biography": "Chidubem is a Computer Science PhD student at the University College Dublin."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-05T17:20:58.892668+00:00",
  "description": "",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Supercharging your data science workflows using GitHub Actions",
  "abstract": "Most data scientists and Machine Learning practitioners will agree that they do not want to spend their valuable time tinkering with redundant scripts. In this talk, I will describe a relatively new CI/CD tool - Github Actions. This talk will describe how one can leverage the power of GitHub Actions to escalate their efficiency as a data scientist. At the end of this talk, attendees will leave with a fresh perspective on CI/CD and be empowered to take their workflows to the next level."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "RGT8RF",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Ollin D. Langle-Chimal",
    "code": "DRF93A",
    "biography": "PhD student at The University of Vermont's Complex Systems Center as part of the Neurobotics Lab.\r\nFormer Data Scientist at the Mexican Department of Social Development.\r\nInterested in complex networks, machine learning and statistics."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-04T19:15:32.391312+00:00",
  "description": "Embedding approaches have been proved to be very successful in several Natural Language Processing tasks. Language itself can be thought of as a graph structure where each word can be represented as a vertex and the edges between them are their transition probability.\r\nWith this reasoning algorithms such as Word2Vec and current state of the art convolutional neural network techniques have been ported and proposed to the graph world in order to tackle questions like node and graph classification, link prediction and spreading processes forecasting.\r\nWe will discuss this techniques and their basic implementation in Julia.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Machine Learning in Graphs",
  "abstract": "We will talk about the graph embedding paradigm for tackling machine learning tasks in this type of structures and their implementation in Julia."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "SNDBVR",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/298918_10151387462991265_1657761683_n_PDDxM0k.jpg",
    "name": "Minyoung Rho",
    "code": "PE7GUP",
    "biography": "Postdoctoral Researcher in Economics at MOVE, Universitat Autònoma de Barcelona, and Barcelona GSE\r\nResearch Interests: Structural Microeconomics, Econometrics, and Mechanism Design \r\nReceived PhD in Economics from Carnegie Mellon University in 2019"
   }
  ],
  "internal_notes": "",
  "notes": "The presentation will start with showcasing the base case (with a case study of allocation of student and school in New York City high school matching market). Then, I will move onto the special allocation rule (i.e., affirmative action or special admission rule) and how to generalize.",
  "created": "2020-03-01T17:14:18.272494+00:00",
  "description": "Deferred Acceptance Algorithm has been gaining lots of traction in the recent decades as it provides a fully characterized (with desirable characteristics such as strategy-proofness, proposing-side optimality, and stability) allocation given the rank ordered list from the two sides desired to be matched.* I have written a base DAA; given the input of rank ordered list from the two-sides, the algorithm outputs the final match for all. Moreover, I have also written a special case of DA algorithm when there exist an allocation rule: affirmative action in school choice setting.\r\n\r\n*Strategy-proofness means that it is weakly dominant strategy for participants to submit their true rankings for the match. Proposing-side optimality means that proposing side (of the two side) will not result in a better match than the algorithm output without hurting another pair. Stability means that no pair can deviate from the algorithm output and result in a strictly better output.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Deferred Acceptance with Allocation Rules",
  "abstract": "Given the input of rank ordered list from the two-sides, the Deferred Acceptance Algorithm (DAA) outputs the final match that is stable, strategy-proof, and proposing-side optimal.  Moreover, I have also incorporated a feature to include special allocation rule such as reserved seat for a certain group of participants."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "TACZJT",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Johann-Tobias Schäg",
    "code": "CCLRPG",
    "biography": "Student of Technical Cybernetics and Systems Theory at TU Ilmenau, Germany."
   }
  ],
  "internal_notes": "",
  "notes": "The author will only give a remote presentation and not travel to JuliaCon independent of how Covid19 develops.\r\nHe is open to handing in a pre-recorded presentation if necessary but would like to respond to questions after that.",
  "created": "2020-03-14T15:35:25.561595+00:00",
  "description": "Julia strikes an interesting balance. It is designed to be compiled into fast code by limiting dynamism at run time while still allowing REPL based development. Thus it is not obvious if Julia is suitable for symbolic AI.\r\nJulia has a world age mechanism which makes it more difficult to call dynamically defined functions,  and it's internal representation of code is more complicated than LISP's, which might present further challenges.\r\nIn this talk is based on experience gained while implementing a toy symbolic AI. The presenter will discuss whether more complex and self modifying symbolic AI would be possible to achieve in Julia. If this is the case there should be no problem implementing other symbolic AIs in Julia.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia for Good Old-Fashioned (Symbolic) Artificial Intelligence",
  "abstract": "LISP has been the lingua franca of symbolic AI. Symbolic AI is a paradigm to create algorithms which solve problems by interacting with a symbolic representation of the world.\r\nLISP was a natural choice due to use in teaching and Meta programming facilitates such as the ability to introspect code as data and create new generated code.\r\nJulia's design is inspired by LISP. However Julia poses new challenges. This talk explores whether they can be overcome and if Julia is suitable for Symbolic AI."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "UHLCJR",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/4173925_joT5hst.jpeg",
    "name": "Christine Choirat",
    "code": "UTJBWX",
    "biography": "Dr. Choirat is the Chief Innovation Officer of the Swiss Data Science Center (SDSC, https://datascience.ch/), an initiative to accelerate the use of data science and machine learning techniques within academic disciplines and the industrial sector, in Switzerland and internationally.  She was trained as a statistician (PhD, Paris Dauphine).  At SDSC, she provides leadership over the lifecycle of sponsored projects and partnerships in the domains of environmental science, health IT, health science and technology, personalized medicine, and open science.  She also fosters engagement with partners to facilitate the adoption of FAIR and reproducible data science with the Renku platform (https://renkulab.io/).\r\n\r\nhttps://scholar.harvard.edu/cchoirat"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-03-14T22:18:06.161688+00:00",
  "description": "With RENKU, every step of the data science research that generates new code or data is preserved.  This allows scientists to step backwards through the history of their research and retrieve earlier versions of their methods and results.  RENKU materializes data science recipes and data lineage into a knowledge representation based on the Common Workflow Language standards (CWL), and PROV-O ontology.  Data lineage is automatically recorded and workflow captured within and across RENKU projects, allowing derived data and results to be unambiguously traced back to original raw data sources through all intermediate processing steps.\r\n\r\nA template for using Renku with a Jupyter Julia kernel is available at: https://renkulab.io/projects/cchoirat/julia-template/.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Reproducible data science with the RENKU platform",
  "abstract": "Communities and funding sources are increasingly demanding reproducibility in scientific work.  We present RENKU (https://renkulab.io/): an open-source platform for reproducible data science.  From an end-user perspective, through a unique authentication mechanism, the platform provides a seamless integration of an RStudio Server or a Jupyter notebook, git version control, git LFS to handle data, continuous integration via GitLab, containerization via Docker images that can be reused and shared,"
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "V9DQSA",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "JinGuo Liu",
    "code": "QBUZQE",
    "biography": "A quantum computing geek!\r\nMy recent work is: https://arxiv.org/abs/2003.04617\r\nI am going to QuEra (https://www.quera-computing.com/)."
   }
  ],
  "internal_notes": null,
  "notes": "",
  "created": "2020-03-15T04:03:55.284381+00:00",
  "description": "https://github.com/GiggleLiu/NiLang.jl\r\nhttps://arxiv.org/abs/2003.04617",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/V9DQSA/JuliaReverse_7W2R4pi.png",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [
   {
    "description": "Poster",
    "resource": "/media/juliacon2020/submissions/V9DQSA/resources/NiLang_2_isfUh6l.pdf"
   }
  ],
  "do_not_record": false,
  "title": "NiLang.jl - Reversible computing for future",
  "abstract": "In reversible computing, a program is reversible, which means it can run either forward or backward. Reversible computing features energy efficiency, scalable fault tolerance, scalable debugging, and hardware-level differentiability.\r\nFrom a physical perspective, I will show why reversible computing is the future of computing. From the software perspective, I will explain why reversible computing is an ideal platform for differential programming."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "VFKAA9",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/Profile_80ltq0U.jpg",
    "name": "Chris \"Yoh\" Meyers",
    "code": "JL9UFC",
    "biography": "Fullstack web developer, passionate about capabilities of Julia"
   }
  ],
  "internal_notes": "",
  "notes": "## 1 - Dance.jl\r\nDance.jl is now public on [Github](https://github.com/DanceJL)\r\n\r\n---\r\n## 2 - Propertyanalyser\r\n[Current demo running on Genie.jl](https://my.pcloud.com/publink/show?code=XZmhB9kZCeBc0WBgbUVoAcDketDVsjavtoO7) (password: juliacon)",
  "created": "2020-03-15T23:41:42.555114+00:00",
  "description": "We would like to share with fellow Julia enthusiasts:\r\n- Dance.jl: A new framework for building interactive web services.\r\n- Propertyanalyser: An actual application of Dance.jl as part of an interactive tool for residential real estate valuation through various statistical methods.\r\n\r\n## 1 - Dance.jl \r\nWe would like emphasize that this is not a competition to other packages such as Genie.jl or Mux.jl. Simply our approach is from a more broad understanding of web development, **allowing traction of Julia from non-data scientists**.\r\n\r\nFeatures include:\r\n- Render Dicts & DataFrames into JSON API endpoints and integrate with any frontend framework \r\n- Simplified dymanic url rendering\r\n- Webpack4 integration via plugin (headache for many web developers)\r\n- Database (ClickHouse) plugin\r\n- Tasks queue management\r\n- Docker image to easily run project as isolated web server\r\n\r\n---\r\n## 2 - Propertyanalyser\r\nDemonstration will illustrate following insights, using the Iberian urban real estate market (Madrid, Barcelona, Valencia, Lisbon) as an example:\r\n- Geographic drill-down into property price levels through geographic heatmaps both for purchases and rentals, as well as rental yield\r\n- Residential real estate valuation techniques (e.g. comparison of R2 from linear regression vs neural network)\r\n- Breakdown of value drivers (e.g. pure location vs individual property features such as size, floor level, year of construction, expected rental yield)\r\n- Identification of “*hot deals*” that appear undervalued compared to the local market \r\n\r\n---\r\nWe look forward to exchanging ideas with fellow Julia professionals and to meeting you in person.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Exposing Julia to the frontend web developer via DanceJL",
  "abstract": "This talk will demonstrate how Julians can easily transform their AI output to a modern website, as well as how Julia can become the go-to language for complex web applications. DanceJL can integrate with any frontend web framework of choice, by allowing the framework to easily plugin into the AI/backend logic."
 },
 {
  "content_locale": "en",
  "is_featured": false,
  "code": "VP7LXS",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/MaxTelegram_rzyLlbH.jpg",
    "name": "Maxim Demenkov",
    "code": "97KZUT",
    "biography": "Maxim Demenkov got his PhD in Automatic Control from De Montfort University (UK). He works now as Engineering Mathematician at the Institute of Control Sciences in Moscow, Russia."
   }
  ],
  "internal_notes": null,
  "notes": "",
  "created": "2020-03-15T17:52:44.786280+00:00",
  "description": "",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/VP7LXS/MDemenkov_m6ltuDT.png",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Squaring the circle: polyhedral approximation of convex sets",
  "abstract": "Our method builds a sequence of inner polytopic approximations of a convex set. New vertices of such an approximation are obtained by optimizing linear functions (constructed from the facet-defining inequalities for the inner polytope) over the set. During several decades, it has been reinvented in many different contexts such as concave programming, convex hull computation, computation of Newton polytopes in algebraic geometry, multi-objective optimization and computational molecular biology."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "XXUJ9Y",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Janis Erdmanis",
    "code": "BYKXMD",
    "biography": "My name is Janis (Yanis), and I am currently a PhD candidate for theoretical physics at TU Delft.  I am a curious person and simplicity is what drives me. I am passionately seeking a frame of reference in which perceived complexity becomes simple, short and understandable. That gives me a kinda special feeling of going up to see more. And in the research, I get plenty of opportunities to do that although that is never easy. So I end up building my own stuff with Julia, now I am the founder of PeaceFounder's project."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-02-17T23:29:12.580310+00:00",
  "description": "The main challenge for the remote electronic voting system is to provide a public and trustless cryptographic proof that each vote is produced by a legitimate member who votes only once while still preserving strong privacy guarantees through distributed multiparty computations. Linkable ring signatures with TOR would be excellent but unfortunately are rather expensive computationally and in signature size. Alternatively, one can create an anonymous signature with a blind signature scheme, but it involves authority who has the ability to stuff ballot (no guarantees for legitimacy). \r\n\r\nInstead, I propose to use ballots for creation of a list of anonymous pseudonyms. Each voter participating in ballot secretly generates his pseudonym and puts that in the ballot box whose contents are afterwards published and mutual consent produced. This procedure (braiding) can be repeated with pseudonyms themselves, giving robustness and reasonable convenience as trustless ballots can be made small while still enlarging anonymity set with each ballot. The generated pseudonyms then can be used to sign votes and delivered to the voting box with TOR. To clarify and to check sanity, I chose to implement the protocol in Julia.",
  "answers": [],
  "image": "https://pretalx.com/media/juliacon2020/submissions/XXUJ9Y/peacefounder_geXs7tE.png",
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Julia for cryptography, security and voting",
  "abstract": "Could there be a trustworthy electronic voting system in the Westworld - possessing strong software independence with strong privacy guarantees? I came up with trustless while robust and fairly convenient design based on pseudonym braiding. In this poster, I will briefly review cryptographic packages already available in Julia, ones which I implemented for key exchange, digital signatures, socket encryption and lastly the main ideas of `PeaceVote` package and current challenges."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "YDCSNX",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": "https://pretalx.com/media/avatars/16793_866274106777693_5652454198993778802_n_Wb8GDvk.jpg",
    "name": "Tiago Santos",
    "code": "NLUSQV",
    "biography": "I'm currently a PhD Student from Lisbon, Portugal."
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-02-06T16:51:19.580240+00:00",
  "description": "",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [],
  "do_not_record": false,
  "title": "Control and Automation Software for Chromatographic Processes",
  "abstract": "Most of the commercial softwares that exist to control equipment used in liquid chromatography are quite expensive and limited when it comes to personalized use. To overcome this we developed our own software called *ChromatographyStudio*."
 },
 {
  "content_locale": "en",
  "is_featured": true,
  "code": "ZAGFAM",
  "track": null,
  "state": "confirmed",
  "duration": 5,
  "speakers": [
   {
    "avatar": null,
    "name": "Henki Ashadi",
    "code": "ZLQHXW",
    "biography": "Name          : Dr.-Ing. Henki Wibowo Ashadi\r\noccupation : Lecture at universitas indonesia\r\nborn            : 9 july, 1964\r\nAdress        : Civil Engineering Department, Faculty of Engineering,\r\n                       Universitas Indonesia\r\n                      Kampus UI Depok, Depok 16424, Indonesia\r\nEmail          : henki@eng.ui.ac.id; henki.wibowo@ui.ac.id; henki.ashadi@gmail.com"
   }
  ],
  "internal_notes": "",
  "notes": "",
  "created": "2020-02-29T01:34:41.041976+00:00",
  "description": "Indonesia is one of country lie  in equator consist of thousands islands which prone to many natural hazards such as floods, vulcanous eruptions, earthquakes, and recently tsunamis.  Engineer must studies not only the effects of permanent or gravitational and life loads to the buildings but also, lateral loads which simulate the effect of winds and earthquakes loads. To fullfill these tasks, many analysis should be done to simulate different loads to the building to achieve the most economical, easy to construct, comfortable, building and following the safety index of building code. \r\n\r\nThe modern structural analysis will use joint coordinates, type of joints, member properties and distributions of applied loads to produce  exact analysis in minutes. The result will specifies the force of all members, reactions and displacement of the joints of the members. Using stiffness matrix method, equilibrium equations is constructed in term of unknown joint displacement, and solved according to the loads applied.\r\n\r\nJulia language is very suitable tool to be used for these kinds analysis.  For common building, constructing the stiffness matrix and solving according to the compatibility condition, the computation will be needed a fraction of second compare to the available software written in fortran will solve it within seconds.\r\n\r\nThe others advantages of julia is \"free\", means all engineer can use and analyze their structures easily and finally, the society will get an economical, hazards resistant building.",
  "answers": [],
  "image": null,
  "slot_count": 1,
  "slot": {
   "start": null,
   "room": null,
   "end": null
  },
  "submission_type": {
   "en": "Poster"
  },
  "resources": [
   {
    "description": "poster juliacon2020_ashadi",
    "resource": "/media/juliacon2020/submissions/ZAGFAM/resources/juliacon_poster_1jl_henki_w_ashadi_pmshPl6.pdf"
   }
  ],
  "do_not_record": false,
  "title": "Julia for Structural Engineering",
  "abstract": "Structural analysis is an important branch knowledge for a civil engineer, to study the influence of  all possible enviromental aspects such as winds, snow, earthquakes or even tsunami to the buildings.  If the design covers these possible aspects above, it will determine the survival of the structure and people itself. For this purpose, the application of julia language in structure analysis will be shown, and compared to the result with the other available softwares."
 }
]
